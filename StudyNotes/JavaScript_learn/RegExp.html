<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>RILEY</title>
</head>

<body>
    <h1>语法</h1>
    <p>/正则表达式主体/修饰符(可选)</p>
    <p>或者通过new RegExp('正则表达式主体')创建一个RegExp对象</p>

    <h1>.可以匹配任意一个字符</h1>
    <p>'js.'可以匹配'jsp'、'jss'、'js!'等等</p>

    <h1>长度</h1>
    <p>
        用*表示任意个字符（包括0个）<br>
        用+表示至少一个字符<br>
        用?表示0个或1个字符<br>
        用{n}表示n个字符<br>
        用{n,m}表示n~m个字符
    </p>

    <h1>常见元字符</h1>
    <p>\d 匹配一个数字</p>
    <p>\w 匹配一个数字、字母或下划线</p>
    <p>\s 匹配一个空白字符（比如空格、制表符、换行符等等）</p>
    <p>变成大写之后就表示相反含义</p>
    <p>\D 匹配一个非数字字符</p>
    <p>\W 匹配一个非单词字符</p>
    <p>\S 匹配一个非空白字符</p>

    <h1>常见方括号</h1>
    <p>用[]表示范围</p>
    <p>[0-9] 匹配任何一个从 0 至 9 的数字</p>
    <p>[a-z] 匹配任何一个从小写 a 到小写 z 的字符</p>
    <p>[A-Z] 匹配任何一个从大写 A 到大写 Z 的字符</p>
    <p>[0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线</p>
    <p>[0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等</p>
    <p>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名</p>

    <h1>分组</h1>
    <p>用()表示的就是要提取的分组</p>
    <p>^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码</p>
    <script>
        var re2 = /^(\d{3})-(\d{3,8})$/;
        re2.exec('010-12345'); // ['010-12345', '010', '12345']
        re2.exec('010 12345'); // null
    </script>
    <p>如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出子串来</p>

    <h1>其他</h1>
    <p>A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'</p>
    <p>^表示行的开头，^\d表示必须以数字开头</p>
    <p>$表示行的结束，\d$表示必须以数字结束</p>
    <p>js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了</p>

    <h1>贪婪匹配</h1>
    <p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符</p>
    <p>
        比如：<br>
        var re = /^(\d+)(0*)$/;<br>
        re.exec('102300'); // ['102300', '102300', '']
    </p>
    <p>加个?就可以让\d+采用懒惰匹配，虽然是尽可能匹配少的字符，但并不是特别懒惰，你自己试吧</p>
    <p>
        var re = /^(\d+?)(0*)$/;<br>
        re.exec('102300'); // ['102300', '1023', '00']
    </p>

    <h1>方法</h1>
    <p>test() 用于测试给定的字符串是否符合条件</p>
    <p>
        exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串<br>
        exec()方法在匹配失败时返回null
    </p>
    <p>match() 如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配，返回的匹配文本信息有点复杂，自己试吧。如果没有找到任何匹配的文本， match() 将返回 null。如果有标志g，则返回一个数组，里面是所有匹配到的文本</p>

    <h1>修饰符</h1>
    <p>g：全局匹配</p>
    <p>全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示下一次搜索应该开始的索引</p>
    <p>
        var s = 'JavaScript, VBScript, JScript and ECMAScript';<br>
        var re=/[a-zA-Z]+Script/g;<br><br>

        re.exec(s); // ['JavaScript']<br>
        re.lastIndex; // 10<br><br>

        re.exec(s); // ['VBScript']<br>
        re.lastIndex; // 20<br><br>

        re.exec(s); // ['JScript']<br>
        re.lastIndex; // 29<br><br>

        re.exec(s); // ['ECMAScript']<br>
        re.lastIndex; // 44<br><br>

        re.exec(s); // null，直到结束仍没有匹配到
    </p>
    <p>i：表示忽略大小写</p>

    <h1>例子</h1>
    <p>/\d{3}\s+\d{3,8}/：3个数字，然后至少一个空白字符，然后3~8个数字</p>
    <p>如果要匹配'010-12345'这样的号码，就用/\d{3}\-\d{3,8}/，因为'-'是特殊字符，所以要用'\'转义</p>
    <script>
        var re = /^\d{3}\-\d{3,8}$/;
        // var re = new RegExp('^\\d{3}\\-\\d{3,8}$'); //注意要把\变成\\，这是因为字符串的转义问题
        console.log(re.test('010-12345')); // true
        console.log(re.test('010-1234x')); // false
        console.log(re.test('010 12345')); // false
    </script>
    <p>
        我们用正则表达式切分字符串比用固定的字符更灵活<br>
        常见的切分代码是：'a b c'.split(' '); // ['a', 'b', '', '', 'c']<br>
        用正则表达式：'a b c'.split(/\s+/); // ['a', 'b', 'c']<br>
        加入,和;试试：'a,b;; c d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']<br>
    </p>
    <p>
        var re =<br>
        /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;<br>
        re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']
    </p>
    <p>
        var str="The rain in SPAIN stays mainly in the plain"; <br>
	    str.match(/ain/g); // ['ain','ain','ain']
    </p>
</body>

</html>